# Copilot Instructions for Minesweeper AI Project

## Project Overview
This is a classic Windows 3.1 style Minesweeper game implemented in Python with tkinter, designed to be AI training ready. The project follows object-oriented design principles and maintains clean separation between game logic and UI.

## Development Environment
- **Operating System**: Windows
- **Shell**: bash.exe
- **Path Syntax**: Use forward slashes for all terminal commands and file paths in scripts
- **Terminal Commands**: All commands should be compatible with bash shell syntax

## Development Standards

### Object-Oriented Design Principles
- **Single Responsibility Principle**: Each class should have one reason to change
- **Open/Closed Principle**: Classes should be open for extension, closed for modification
- **Dependency Inversion**: Depend on abstractions, not concretions
- **Encapsulation**: Keep internal state private, expose through well-defined interfaces
- **Composition over Inheritance**: Favor composition when possible

### Directory Structure Best Practices
Follow the established structure:
```
├── main.py                 # Entry point
├── requirements.txt        # Dependencies
├── test_*.py              # Test files at root level
├── tests/                 # Comprehensive test suite
├── src/                   # Source code
│   ├── game/             # Core game logic (no UI dependencies)
│   ├── ui/               # User interface components
│   └── utils/            # Shared utilities
└── docs/                 # Documentation
```

### Code Organization Guidelines
- Keep game logic (src/game/) completely independent of UI
- Use type hints for all function parameters and return values
- Follow PEP 8 style guidelines
- Use descriptive class and method names
- Add comprehensive docstrings for all public methods
- Implement proper error handling and validation

## Testing Requirements

### Test Framework
- **Use pytest** for all testing
- Run tests after completing each prompt and fix any errors
- Maintain minimum 80% test coverage

### Test Structure
- Create test files with `test_` prefix
- Use descriptive test method names: `test_should_reveal_cell_when_clicked`
- Group related tests in test classes
- Use pytest fixtures for test setup and teardown

### Test Categories
1. **Unit Tests**: Test individual classes and methods in isolation
2. **Integration Tests**: Test interaction between components
3. **Game Logic Tests**: Verify game rules and state transitions
4. **UI Tests**: Test user interface components (when applicable)

### Required Test Coverage
- All public methods in game logic classes
- Edge cases and error conditions
- Game state transitions (ready → playing → won/lost)
- Mine placement and revelation logic
- Flag/unflag functionality
- Win/lose conditions
- Board initialization and reset

## Implementation Workflow

### For Each Development Task:
1. **Design First**: Plan the object-oriented approach
2. **Implement**: Follow OOP principles and coding standards
3. **Test**: Write comprehensive pytest tests
4. **Run Tests**: Execute `pytest` and ensure all tests pass
5. **Fix Issues**: Address any test failures or errors
6. **Refactor**: Improve code quality while maintaining test coverage

### Test Execution Commands
```bash
# Run all tests
pytest

# Run with coverage report
pytest --cov=src --cov-report=html

# Run specific test file
pytest tests/test_board.py

# Run with verbose output
pytest -v

# Run and stop on first failure
pytest -x
```

## Code Quality Standards

### Error Handling
- Use appropriate exception types
- Validate input parameters
- Handle edge cases gracefully
- Provide meaningful error messages

### Documentation
- Write clear docstrings for all public APIs
- Include parameter types and descriptions
- Document return values and exceptions
- Add inline comments for complex logic

### Performance Considerations
- Optimize algorithms for large boards (expert level: 16x30)
- Avoid unnecessary object creation in game loops
- Use efficient data structures
- Profile performance-critical code paths

## AI Training Considerations
- Keep game logic separate from UI for easy AI integration
- Provide methods to get complete game state
- Allow programmatic game actions (reveal, flag)
- Support game state serialization/deserialization
- Implement observable pattern for state changes

## Specific Guidelines for This Project

### Game Logic (src/game/)
- `GameBoard` class manages all game state and rules
- `Cell` class represents individual board cells
- Use enums for game states and cell states
- Implement proper mine placement algorithms
- Handle auto-revelation of adjacent empty cells

### UI Components (src/ui/)
- Keep UI components loosely coupled to game logic
- Use observer pattern for game state updates
- Implement proper event handling
- Follow Windows 3.1 visual design principles

### Testing Priorities
1. Core game mechanics (mine placement, revelation, flagging)
2. Win/lose condition detection
3. Board initialization and reset functionality
4. Edge cases (first click safety, boundary conditions)
5. State management and transitions

Remember: **Always run pytest after implementing any changes and fix all errors before considering the task complete.**
